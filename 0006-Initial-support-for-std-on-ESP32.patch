From 1fc56593f348b6c7a3a2b3d63d35d3a07078941a Mon Sep 17 00:00:00 2001
From: Ivan Markov <ivan.markov@gmail.com>
Date: Thu, 12 Nov 2020 21:44:48 +0200
Subject: [PATCH 6/6] Initial support for std on ESP32

---
 library/panic_unwind/src/lib.rs               |   2 +-
 library/std/build.rs                          |   1 +
 library/std/src/os/mod.rs                     |   2 +
 library/std/src/os/none/fs.rs                 | 126 ++++++++++++++++++
 library/std/src/os/none/mod.rs                |   6 +
 library/std/src/os/none/raw.rs                |  74 ++++++++++
 library/std/src/sys/unix/alloc.rs             |   5 +
 library/std/src/sys/unix/condvar.rs           |   6 +-
 library/std/src/sys/unix/env.rs               |  11 ++
 library/std/src/sys/unix/fd.rs                |  25 +++-
 library/std/src/sys/unix/fs.rs                |  29 ++--
 library/std/src/sys/unix/mod.rs               |  11 +-
 library/std/src/sys/unix/net.rs               |   9 +-
 library/std/src/sys/unix/os.rs                |  20 ++-
 library/std/src/sys/unix/process/mod.rs       |   5 +-
 .../sys/unix/process/process_unsupported.rs   | 110 +++++++++++++++
 library/std/src/sys/unix/thread.rs            |  82 +++++++++---
 library/std/src/sys/unix/time.rs              |   4 +-
 library/std/src/sys_common/alloc.rs           |   3 +-
 19 files changed, 488 insertions(+), 43 deletions(-)
 create mode 100644 library/std/src/os/none/fs.rs
 create mode 100644 library/std/src/os/none/mod.rs
 create mode 100644 library/std/src/os/none/raw.rs
 create mode 100644 library/std/src/sys/unix/process/process_unsupported.rs

diff --git a/library/panic_unwind/src/lib.rs b/library/panic_unwind/src/lib.rs
index 682289384c8..fbac40aa8da 100644
--- a/library/panic_unwind/src/lib.rs
+++ b/library/panic_unwind/src/lib.rs
@@ -51,7 +51,7 @@ cfg_if::cfg_if! {
         all(target_family = "windows", target_env = "gnu"),
         target_os = "cloudabi",
         target_os = "psp",
-        target_family = "unix",
+        all(target_family = "unix", not(target_env = "newlib")),
         all(target_vendor = "fortanix", target_env = "sgx"),
     ))] {
         // Rust runtime's startup objects depend on these symbols, so make them public.
diff --git a/library/std/build.rs b/library/std/build.rs
index f2ed7552afb..758c064db8d 100644
--- a/library/std/build.rs
+++ b/library/std/build.rs
@@ -70,6 +70,7 @@ fn main() {
         || target.contains("vxworks")
         || target.contains("wasm32")
         || target.contains("asmjs")
+        || target.contains("esp32")
     {
         // These platforms don't have any special requirements.
     } else {
diff --git a/library/std/src/os/mod.rs b/library/std/src/os/mod.rs
index fd6ee088e96..d9903c91fc8 100644
--- a/library/std/src/os/mod.rs
+++ b/library/std/src/os/mod.rs
@@ -70,5 +70,7 @@ pub mod solaris;
 pub mod vxworks;
 #[cfg(target_os = "wasi")]
 pub mod wasi;
+#[cfg(all(target_os = "none", target_env = "newlib", target_vendor = "espressif"))]
+pub mod none;
 
 pub mod raw;
diff --git a/library/std/src/os/none/fs.rs b/library/std/src/os/none/fs.rs
new file mode 100644
index 00000000000..b1fa8836911
--- /dev/null
+++ b/library/std/src/os/none/fs.rs
@@ -0,0 +1,126 @@
+#![stable(feature = "metadata_ext", since = "1.1.0")]
+
+use crate::fs::Metadata;
+use crate::sys_common::AsInner;
+
+#[allow(deprecated)]
+use crate::os::none::raw;
+
+/// OS-specific extensions to [`fs::Metadata`].
+///
+/// [`fs::Metadata`]: crate::fs::Metadata
+#[stable(feature = "metadata_ext", since = "1.1.0")]
+pub trait MetadataExt {
+    #[stable(feature = "metadata_ext", since = "1.1.0")]
+    #[rustc_deprecated(
+        since = "1.8.0",
+        reason = "deprecated in favor of the accessor \
+                  methods of this trait"
+    )]
+    #[allow(deprecated)]
+    fn as_raw_stat(&self) -> &raw::stat;
+
+    #[stable(feature = "metadata_ext2", since = "1.8.0")]
+    fn st_dev(&self) -> u64;
+    #[stable(feature = "metadata_ext2", since = "1.8.0")]
+    fn st_ino(&self) -> u64;
+    #[stable(feature = "metadata_ext2", since = "1.8.0")]
+    fn st_mode(&self) -> u32;
+    #[stable(feature = "metadata_ext2", since = "1.8.0")]
+    fn st_nlink(&self) -> u64;
+    #[stable(feature = "metadata_ext2", since = "1.8.0")]
+    fn st_uid(&self) -> u32;
+    #[stable(feature = "metadata_ext2", since = "1.8.0")]
+    fn st_gid(&self) -> u32;
+    #[stable(feature = "metadata_ext2", since = "1.8.0")]
+    fn st_rdev(&self) -> u64;
+    #[stable(feature = "metadata_ext2", since = "1.8.0")]
+    fn st_size(&self) -> u64;
+    #[stable(feature = "metadata_ext2", since = "1.8.0")]
+    fn st_atime(&self) -> i64;
+    #[stable(feature = "metadata_ext2", since = "1.8.0")]
+    fn st_atime_nsec(&self) -> i64;
+    #[stable(feature = "metadata_ext2", since = "1.8.0")]
+    fn st_mtime(&self) -> i64;
+    #[stable(feature = "metadata_ext2", since = "1.8.0")]
+    fn st_mtime_nsec(&self) -> i64;
+    #[stable(feature = "metadata_ext2", since = "1.8.0")]
+    fn st_ctime(&self) -> i64;
+    #[stable(feature = "metadata_ext2", since = "1.8.0")]
+    fn st_ctime_nsec(&self) -> i64;
+    #[stable(feature = "metadata_ext2", since = "1.8.0")]
+    fn st_crtime(&self) -> i64;
+    #[stable(feature = "metadata_ext2", since = "1.8.0")]
+    fn st_crtime_nsec(&self) -> i64;
+    #[stable(feature = "metadata_ext2", since = "1.8.0")]
+    fn st_blksize(&self) -> u64;
+    #[stable(feature = "metadata_ext2", since = "1.8.0")]
+    fn st_blocks(&self) -> u64;
+}
+
+#[stable(feature = "metadata_ext", since = "1.1.0")]
+impl MetadataExt for Metadata {
+    #[allow(deprecated)]
+    fn as_raw_stat(&self) -> &raw::stat {
+        unsafe { &*(self.as_inner().as_inner() as *const libc::stat as *const raw::stat) }
+    }
+    fn st_dev(&self) -> u64 {
+        self.as_inner().as_inner().st_dev as u64
+    }
+    fn st_ino(&self) -> u64 {
+        self.as_inner().as_inner().st_ino as u64
+    }
+    fn st_mode(&self) -> u32 {
+        self.as_inner().as_inner().st_mode as u32
+    }
+    fn st_nlink(&self) -> u64 {
+        self.as_inner().as_inner().st_nlink as u64
+    }
+    fn st_uid(&self) -> u32 {
+        self.as_inner().as_inner().st_uid as u32
+    }
+    fn st_gid(&self) -> u32 {
+        self.as_inner().as_inner().st_gid as u32
+    }
+    fn st_rdev(&self) -> u64 {
+        self.as_inner().as_inner().st_rdev as u64
+    }
+    fn st_size(&self) -> u64 {
+        self.as_inner().as_inner().st_size as u64
+    }
+    fn st_atime(&self) -> i64 {
+        self.as_inner().as_inner().st_atime as i64
+    }
+    fn st_atime_nsec(&self) -> i64 {
+        //self.as_inner().as_inner().st_atime_nsec as i64
+        0
+    }
+    fn st_mtime(&self) -> i64 {
+        self.as_inner().as_inner().st_mtime as i64
+    }
+    fn st_mtime_nsec(&self) -> i64 {
+        //self.as_inner().as_inner().st_mtime_nsec as i64
+        0
+    }
+    fn st_ctime(&self) -> i64 {
+        self.as_inner().as_inner().st_ctime as i64
+    }
+    fn st_ctime_nsec(&self) -> i64 {
+        //self.as_inner().as_inner().st_ctime_nsec as i64
+        0
+    }
+    fn st_crtime(&self) -> i64 {
+        //self.as_inner().as_inner().st_crtime as i64
+        0
+    }
+    fn st_crtime_nsec(&self) -> i64 {
+        //self.as_inner().as_inner().st_crtime_nsec as i64
+        0
+    }
+    fn st_blksize(&self) -> u64 {
+        self.as_inner().as_inner().st_blksize as u64
+    }
+    fn st_blocks(&self) -> u64 {
+        self.as_inner().as_inner().st_blocks as u64
+    }
+}
diff --git a/library/std/src/os/none/mod.rs b/library/std/src/os/none/mod.rs
new file mode 100644
index 00000000000..4d1b3416854
--- /dev/null
+++ b/library/std/src/os/none/mod.rs
@@ -0,0 +1,6 @@
+//! Definitions for bare metal platforms that nevertheless do have a POSIX compatibility layer
+
+#![stable(feature = "raw_ext", since = "1.1.0")]
+
+pub mod fs;
+pub mod raw;
diff --git a/library/std/src/os/none/raw.rs b/library/std/src/os/none/raw.rs
new file mode 100644
index 00000000000..f5123b8a935
--- /dev/null
+++ b/library/std/src/os/none/raw.rs
@@ -0,0 +1,74 @@
+//! Bare-metal (usually newlib based) raw type definitions
+
+#![stable(feature = "raw_ext", since = "1.1.0")]
+#![allow(deprecated)]
+
+use crate::os::raw::c_long;
+use crate::os::unix::raw::{gid_t, uid_t};
+
+// Use the direct definition of usize, instead of uintptr_t like in libc
+#[stable(feature = "pthread_t", since = "1.8.0")]
+pub type pthread_t = libc::pthread_t;
+
+#[stable(feature = "raw_ext", since = "1.1.0")]
+pub type blkcnt_t = libc::blkcnt_t;
+
+#[stable(feature = "raw_ext", since = "1.1.0")]
+pub type blksize_t = libc::blksize_t;
+#[stable(feature = "raw_ext", since = "1.1.0")]
+pub type dev_t = libc::dev_t;
+#[stable(feature = "raw_ext", since = "1.1.0")]
+pub type ino_t = libc::ino_t;
+#[stable(feature = "raw_ext", since = "1.1.0")]
+pub type mode_t = libc::mode_t;
+#[stable(feature = "raw_ext", since = "1.1.0")]
+pub type nlink_t = libc::nlink_t;
+#[stable(feature = "raw_ext", since = "1.1.0")]
+pub type off_t = libc::off_t;
+
+#[stable(feature = "raw_ext", since = "1.1.0")]
+pub type time_t = libc::time_t;
+
+#[repr(C)]
+#[derive(Clone)]
+#[stable(feature = "raw_ext", since = "1.1.0")]
+pub struct stat {
+    #[stable(feature = "raw_ext", since = "1.1.0")]
+    pub st_dev: dev_t,
+    #[stable(feature = "raw_ext", since = "1.1.0")]
+    pub st_ino: ino_t,
+    #[stable(feature = "raw_ext", since = "1.1.0")]
+    pub st_mode: mode_t,
+    #[stable(feature = "raw_ext", since = "1.1.0")]
+    pub st_nlink: nlink_t,
+    #[stable(feature = "raw_ext", since = "1.1.0")]
+    pub st_uid: uid_t,
+    #[stable(feature = "raw_ext", since = "1.1.0")]
+    pub st_gid: gid_t,
+    #[stable(feature = "raw_ext", since = "1.1.0")]
+    pub st_rdev: dev_t,
+    #[stable(feature = "raw_ext", since = "1.1.0")]
+    pub st_size: off_t,
+    #[stable(feature = "raw_ext", since = "1.1.0")]
+    pub st_atime: time_t,
+    // #[stable(feature = "raw_ext", since = "1.1.0")]
+    // pub st_atime_nsec: c_long,
+    #[stable(feature = "raw_ext", since = "1.1.0")]
+    pub st_mtime: time_t,
+    // #[stable(feature = "raw_ext", since = "1.1.0")]
+    // pub st_mtime_nsec: c_long,
+    #[stable(feature = "raw_ext", since = "1.1.0")]
+    pub st_ctime: time_t,
+    // #[stable(feature = "raw_ext", since = "1.1.0")]
+    // pub st_ctime_nsec: c_long,
+    // #[stable(feature = "raw_ext", since = "1.1.0")]
+    // pub st_crtime: time_t,
+    // #[stable(feature = "raw_ext", since = "1.1.0")]
+    // pub st_crtime_nsec: c_long,
+    #[stable(feature = "raw_ext", since = "1.1.0")]
+    pub st_blksize: blksize_t,
+    #[stable(feature = "raw_ext", since = "1.1.0")]
+    pub st_blocks: blkcnt_t,
+    // #[stable(feature = "raw_ext", since = "1.1.0")]
+    // pub st_type: u32,
+}
diff --git a/library/std/src/sys/unix/alloc.rs b/library/std/src/sys/unix/alloc.rs
index 964abe8b8c9..63df117542e 100644
--- a/library/std/src/sys/unix/alloc.rs
+++ b/library/std/src/sys/unix/alloc.rs
@@ -85,6 +85,11 @@ cfg_if::cfg_if! {
         unsafe fn aligned_malloc(layout: &Layout) -> *mut u8 {
             libc::aligned_alloc(layout.align(), layout.size()) as *mut u8
         }
+    } else if #[cfg(target_arch = "xtensa")] {
+        #[inline]
+        unsafe fn aligned_malloc(layout: &Layout) -> *mut u8 {
+            libc::malloc(layout.size()) as *mut u8
+        }
     } else {
         #[inline]
         unsafe fn aligned_malloc(layout: &Layout) -> *mut u8 {
diff --git a/library/std/src/sys/unix/condvar.rs b/library/std/src/sys/unix/condvar.rs
index e38f91af9f0..c5c19f982c8 100644
--- a/library/std/src/sys/unix/condvar.rs
+++ b/library/std/src/sys/unix/condvar.rs
@@ -30,7 +30,8 @@ impl Condvar {
         target_os = "ios",
         target_os = "l4re",
         target_os = "android",
-        target_os = "redox"
+        target_os = "redox",
+        target_os = "none"
     ))]
     pub unsafe fn init(&mut self) {}
 
@@ -39,7 +40,8 @@ impl Condvar {
         target_os = "ios",
         target_os = "l4re",
         target_os = "android",
-        target_os = "redox"
+        target_os = "redox",
+        target_os = "none"
     )))]
     pub unsafe fn init(&mut self) {
         use crate::mem::MaybeUninit;
diff --git a/library/std/src/sys/unix/env.rs b/library/std/src/sys/unix/env.rs
index 7f5e9b04dba..d51e6308390 100644
--- a/library/std/src/sys/unix/env.rs
+++ b/library/std/src/sys/unix/env.rs
@@ -173,3 +173,14 @@ pub mod os {
     pub const EXE_SUFFIX: &str = "";
     pub const EXE_EXTENSION: &str = "";
 }
+
+#[cfg(all(target_os = "none", target_env = "newlib"))]
+pub mod os {
+    pub const FAMILY: &str = "unix";
+    pub const OS: &str = "none";
+    pub const DLL_PREFIX: &str = "lib";
+    pub const DLL_SUFFIX: &str = ".so";
+    pub const DLL_EXTENSION: &str = "so";
+    pub const EXE_SUFFIX: &str = "";
+    pub const EXE_EXTENSION: &str = "";
+}
diff --git a/library/std/src/sys/unix/fd.rs b/library/std/src/sys/unix/fd.rs
index d3a279a2355..a1c21694172 100644
--- a/library/std/src/sys/unix/fd.rs
+++ b/library/std/src/sys/unix/fd.rs
@@ -84,6 +84,7 @@ impl FileDesc {
         Ok(ret as usize)
     }
 
+    #[cfg(not(target_env = "newlib"))]
     pub fn read_vectored(&self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {
         let ret = cvt(unsafe {
             libc::readv(
@@ -93,11 +94,16 @@ impl FileDesc {
             )
         })?;
         Ok(ret as usize)
-    }
+     }
 
+     #[cfg(target_env = "newlib")]
+     pub fn read_vectored(&self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {
+         return crate::io::default_read_vectored(|b| self.read(b), bufs);
+     }
+ 
     #[inline]
     pub fn is_read_vectored(&self) -> bool {
-        true
+        cfg!(not(target_env = "newlib"))
     }
 
     pub fn read_to_end(&self, buf: &mut Vec<u8>) -> io::Result<usize> {
@@ -141,6 +147,7 @@ impl FileDesc {
         Ok(ret as usize)
     }
 
+    #[cfg(not(target_env = "newlib"))]
     pub fn write_vectored(&self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {
         let ret = cvt(unsafe {
             libc::writev(
@@ -152,9 +159,14 @@ impl FileDesc {
         Ok(ret as usize)
     }
 
+    #[cfg(target_env = "newlib")]
+    pub fn write_vectored(&self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {
+        return crate::io::default_write_vectored(|b| self.write(b), bufs);
+    }
+
     #[inline]
     pub fn is_write_vectored(&self) -> bool {
-        true
+        cfg!(not(target_env = "newlib"))
     }
 
     pub fn write_at(&self, buf: &[u8], offset: u64) -> io::Result<usize> {
@@ -192,7 +204,7 @@ impl FileDesc {
     }
 
     #[cfg(not(any(
-        target_env = "newlib",
+        target_os = "none",
         target_os = "solaris",
         target_os = "illumos",
         target_os = "emscripten",
@@ -210,7 +222,6 @@ impl FileDesc {
         }
     }
     #[cfg(any(
-        target_env = "newlib",
         target_os = "solaris",
         target_os = "illumos",
         target_os = "emscripten",
@@ -231,6 +242,10 @@ impl FileDesc {
             Ok(())
         }
     }
+    #[cfg(target_os = "none")]
+    pub fn set_cloexec(&self) -> io::Result<()> {
+        Ok(())
+    }
 
     #[cfg(target_os = "linux")]
     pub fn set_nonblocking(&self, nonblocking: bool) -> io::Result<()> {
diff --git a/library/std/src/sys/unix/fs.rs b/library/std/src/sys/unix/fs.rs
index 96594095cc3..73c63006ec2 100644
--- a/library/std/src/sys/unix/fs.rs
+++ b/library/std/src/sys/unix/fs.rs
@@ -1,5 +1,4 @@
 use crate::os::unix::prelude::*;
-
 use crate::ffi::{CStr, CString, OsStr, OsString};
 use crate::fmt;
 use crate::io::{self, Error, ErrorKind, IoSlice, IoSliceMut, SeekFrom};
@@ -297,7 +296,7 @@ impl FileAttr {
 
 #[cfg(not(target_os = "netbsd"))]
 impl FileAttr {
-    #[cfg(not(target_os = "vxworks"))]
+    #[cfg(all(not(target_os = "vxworks"), not(target_env = "newlib")))]
     pub fn modified(&self) -> io::Result<SystemTime> {
         Ok(SystemTime::from(libc::timespec {
             tv_sec: self.stat.st_mtime as libc::time_t,
@@ -305,7 +304,7 @@ impl FileAttr {
         }))
     }
 
-    #[cfg(target_os = "vxworks")]
+    #[cfg(any(target_os = "vxworks", target_env = "newlib"))]
     pub fn modified(&self) -> io::Result<SystemTime> {
         Ok(SystemTime::from(libc::timespec {
             tv_sec: self.stat.st_mtime as libc::time_t,
@@ -313,7 +312,7 @@ impl FileAttr {
         }))
     }
 
-    #[cfg(not(target_os = "vxworks"))]
+    #[cfg(all(not(target_os = "vxworks"), not(target_env = "newlib")))]
     pub fn accessed(&self) -> io::Result<SystemTime> {
         Ok(SystemTime::from(libc::timespec {
             tv_sec: self.stat.st_atime as libc::time_t,
@@ -321,7 +320,7 @@ impl FileAttr {
         }))
     }
 
-    #[cfg(target_os = "vxworks")]
+    #[cfg(any(target_os = "vxworks", target_env = "newlib"))]
     pub fn accessed(&self) -> io::Result<SystemTime> {
         Ok(SystemTime::from(libc::timespec {
             tv_sec: self.stat.st_atime as libc::time_t,
@@ -594,7 +593,8 @@ impl DirEntry {
         target_os = "l4re",
         target_os = "fuchsia",
         target_os = "redox",
-        target_os = "vxworks"
+        target_os = "vxworks",
+        target_env = "newlib"
     ))]
     pub fn ino(&self) -> u64 {
         self.entry.d_ino as u64
@@ -633,7 +633,8 @@ impl DirEntry {
         target_os = "emscripten",
         target_os = "l4re",
         target_os = "haiku",
-        target_os = "vxworks"
+        target_os = "vxworks",
+        target_env = "newlib"
     ))]
     fn name_bytes(&self) -> &[u8] {
         unsafe { CStr::from_ptr(self.entry.d_name.as_ptr()).to_bytes() }
@@ -1082,7 +1083,7 @@ pub fn link(src: &Path, dst: &Path) -> io::Result<()> {
     let src = cstr(src)?;
     let dst = cstr(dst)?;
     cfg_if::cfg_if! {
-        if #[cfg(any(target_os = "vxworks", target_os = "redox", target_os = "android"))] {
+        if #[cfg(any(target_os = "vxworks", target_os = "redox", target_os = "android", target_env = "newlib"))] {
             // VxWorks, Redox, and old versions of Android lack `linkat`, so use
             // `link` instead. POSIX leaves it implementation-defined whether
             // `link` follows symlinks, so rely on the `symlink_hard_link` test
@@ -1164,6 +1165,18 @@ fn open_from(from: &Path) -> io::Result<(crate::fs::File, crate::fs::Metadata)>
     Ok((reader, metadata))
 }
 
+#[cfg(target_os = "none")]
+fn open_to_and_set_permissions(
+    to: &Path,
+    reader_metadata: crate::fs::Metadata,
+) -> io::Result<(crate::fs::File, crate::fs::Metadata)> {
+    use crate::fs::OpenOptions;
+    let writer = OpenOptions::new().open(to)?;
+    let writer_metadata = writer.metadata()?;
+    Ok((writer, writer_metadata))
+}
+
+#[cfg(not(target_os = "none"))]
 fn open_to_and_set_permissions(
     to: &Path,
     reader_metadata: crate::fs::Metadata,
diff --git a/library/std/src/sys/unix/mod.rs b/library/std/src/sys/unix/mod.rs
index b28c6d85b7c..018f0fc0195 100644
--- a/library/std/src/sys/unix/mod.rs
+++ b/library/std/src/sys/unix/mod.rs
@@ -33,15 +33,19 @@ pub use crate::os::openbsd as platform;
 pub use crate::os::redox as platform;
 #[cfg(all(not(doc), target_os = "solaris"))]
 pub use crate::os::solaris as platform;
+#[cfg(all(not(doc), all(target_os = "none", target_env = "newlib")))]
+pub use crate::os::none as platform;
 
 pub use self::rand::hashmap_random_keys;
 pub use libc::strlen;
 
+#[cfg(not(target_os = "none"))]
 #[macro_use]
 pub mod weak;
 
 pub mod alloc;
 pub mod android;
+#[cfg_attr(target_os = "none", path = "../unsupported/args.rs")]
 pub mod args;
 pub mod cmath;
 pub mod condvar;
@@ -64,6 +68,7 @@ pub mod path;
 pub mod pipe;
 pub mod process;
 pub mod rand;
+#[cfg_attr(target_env = "newlib", path = "../wasm/rwlock_atomics.rs")]
 pub mod rwlock;
 pub mod stack_overflow;
 pub mod stdio;
@@ -74,7 +79,11 @@ pub mod time;
 
 pub use crate::sys_common::os_str_bytes as os_str;
 
-#[cfg(not(test))]
+#[cfg(all(not(test), target_os = "none"))]
+pub fn init() {
+}
+
+#[cfg(all(not(test), not(target_os = "none")))]
 pub fn init() {
     // The standard streams might be closed on application startup. To prevent
     // std::io::{stdin, stdout,stderr} objects from using other unrelated file
diff --git a/library/std/src/sys/unix/net.rs b/library/std/src/sys/unix/net.rs
index 378d690f8bf..b27b1702b56 100644
--- a/library/std/src/sys/unix/net.rs
+++ b/library/std/src/sys/unix/net.rs
@@ -9,7 +9,7 @@ use crate::sys_common::net::{getsockopt, setsockopt, sockaddr_to_addr};
 use crate::sys_common::{AsInner, FromInner, IntoInner};
 use crate::time::{Duration, Instant};
 
-use libc::{c_int, c_void, size_t, sockaddr, socklen_t, EAI_SYSTEM, MSG_PEEK};
+use libc::{c_int, c_void, size_t, sockaddr, socklen_t, /*ESPIDFTODO EAI_SYSTEM,*/ MSG_PEEK};
 
 pub use crate::sys::{cvt, cvt_r};
 
@@ -30,9 +30,10 @@ pub fn cvt_gai(err: c_int) -> io::Result<()> {
     // We may need to trigger a glibc workaround. See on_resolver_failure() for details.
     on_resolver_failure();
 
-    if err == EAI_SYSTEM {
-        return Err(io::Error::last_os_error());
-    }
+    //ESPIDFTODO
+    // if err == EAI_SYSTEM {
+    //     return Err(io::Error::last_os_error());
+    // }
 
     let detail = unsafe {
         str::from_utf8(CStr::from_ptr(libc::gai_strerror(err)).to_bytes()).unwrap().to_owned()
diff --git a/library/std/src/sys/unix/os.rs b/library/std/src/sys/unix/os.rs
index d5e14bec765..2589025cec0 100644
--- a/library/std/src/sys/unix/os.rs
+++ b/library/std/src/sys/unix/os.rs
@@ -26,6 +26,11 @@ use crate::vec;
 
 use libc::{c_char, c_int, c_void};
 
+#[cfg(target_os = "none")]
+#[path = "../unsupported/common.rs"]
+#[deny(unsafe_op_in_unsafe_fn)]
+mod unsupported;
+
 const TMPBUF_SZ: usize = 128;
 
 cfg_if::cfg_if! {
@@ -43,7 +48,7 @@ extern "C" {
             target_os = "linux",
             target_os = "emscripten",
             target_os = "fuchsia",
-            target_os = "l4re"
+            target_os = "l4re",
         ),
         link_name = "__errno_location"
     )]
@@ -570,10 +575,16 @@ pub fn unsetenv(n: &OsStr) -> io::Result<()> {
     }
 }
 
+#[cfg(not(target_os = "none"))]
 pub fn page_size() -> usize {
     unsafe { libc::sysconf(libc::_SC_PAGESIZE) as usize }
 }
 
+#[cfg(target_os = "none")]
+pub fn page_size() -> usize {
+    32
+}
+
 pub fn temp_dir() -> PathBuf {
     crate::env::var_os("TMPDIR").map(PathBuf::from).unwrap_or_else(|| {
         if cfg!(target_os = "android") {
@@ -588,6 +599,7 @@ pub fn home_dir() -> Option<PathBuf> {
     return crate::env::var_os("HOME").or_else(|| unsafe { fallback() }).map(PathBuf::from);
 
     #[cfg(any(
+        target_os = "none",
         target_os = "android",
         target_os = "ios",
         target_os = "emscripten",
@@ -598,6 +610,7 @@ pub fn home_dir() -> Option<PathBuf> {
         None
     }
     #[cfg(not(any(
+        target_os = "none",
         target_os = "android",
         target_os = "ios",
         target_os = "emscripten",
@@ -672,3 +685,8 @@ fn parse_glibc_version(version: &str) -> Option<(usize, usize)> {
         _ => None,
     }
 }
+
+#[cfg(target_os = "none")]
+pub fn current_exe() -> io::Result<PathBuf> {
+    unsupported::unsupported()
+}
diff --git a/library/std/src/sys/unix/process/mod.rs b/library/std/src/sys/unix/process/mod.rs
index 1b7b93f9d4a..b9ff30f0bcf 100644
--- a/library/std/src/sys/unix/process/mod.rs
+++ b/library/std/src/sys/unix/process/mod.rs
@@ -4,11 +4,14 @@ pub use crate::ffi::OsString as EnvKey;
 pub use crate::sys_common::process::CommandEnvs;
 
 mod process_common;
-#[cfg(not(target_os = "fuchsia"))]
+#[cfg(all(not(target_os = "fuchsia"), not(target_os = "none")))]
 #[path = "process_unix.rs"]
 mod process_inner;
 #[cfg(target_os = "fuchsia")]
 #[path = "process_fuchsia.rs"]
 mod process_inner;
+#[cfg(target_os = "none")]
+#[path = "process_unsupported.rs"]
+mod process_inner;
 #[cfg(target_os = "fuchsia")]
 mod zircon;
diff --git a/library/std/src/sys/unix/process/process_unsupported.rs b/library/std/src/sys/unix/process/process_unsupported.rs
new file mode 100644
index 00000000000..c526a9ad6e2
--- /dev/null
+++ b/library/std/src/sys/unix/process/process_unsupported.rs
@@ -0,0 +1,110 @@
+use crate::ffi::OsStr;
+use crate::fmt;
+use crate::io;
+use crate::marker::PhantomData;
+use crate::path::Path;
+use crate::sys::fs::File;
+use crate::sys::pipe::AnonPipe;
+use crate::sys_common::process::{CommandEnv, CommandEnvs};
+use crate::ffi::{CStr, CString, OsString};
+
+pub use crate::ffi::OsString as EnvKey;
+
+use crate::sys::process::process_common::*;
+
+use libc::{c_char, c_int, gid_t, uid_t, EXIT_FAILURE, EXIT_SUCCESS};
+
+#[path = "../../unsupported/common.rs"]
+#[deny(unsafe_op_in_unsafe_fn)]
+mod unsupported;
+
+use unsupported::*;
+
+impl Command {
+    pub fn spawn(
+        &mut self,
+        _default: Stdio,
+        _needs_stdin: bool,
+    ) -> io::Result<(Process, StdioPipes)> {
+        unsupported()
+    }
+    
+    pub fn exec(&mut self, default: Stdio) -> io::Error {
+        unsupported_err()
+    }
+}
+
+pub struct Process(Void);
+
+impl Process {
+    pub fn id(&self) -> u32 {
+        match self.0 {}
+    }
+
+    pub fn kill(&mut self) -> io::Result<()> {
+        match self.0 {}
+    }
+
+    pub fn wait(&mut self) -> io::Result<ExitStatus> {
+        match self.0 {}
+    }
+
+    pub fn try_wait(&mut self) -> io::Result<Option<ExitStatus>> {
+        match self.0 {}
+    }
+}
+
+pub struct ExitStatus(Void);
+
+impl ExitStatus {
+    pub fn success(&self) -> bool {
+        match self.0 {}
+    }
+
+    pub fn code(&self) -> Option<i32> {
+        match self.0 {}
+    }
+
+    fn exited(&self) -> bool {
+        match self.0 {}
+    }
+
+    pub fn signal(&self) -> Option<i32> {
+        match self.0 {}
+    }
+}
+
+impl Clone for ExitStatus {
+    fn clone(&self) -> ExitStatus {
+        match self.0 {}
+    }
+}
+
+/// Converts a raw `c_int` to a type-safe `ExitStatus` by wrapping it without copying.
+impl From<c_int> for ExitStatus {
+    fn from(a: c_int) -> ExitStatus {
+        panic!("Unsupported")
+    }
+}
+
+impl Copy for ExitStatus {}
+
+impl PartialEq for ExitStatus {
+    fn eq(&self, _other: &ExitStatus) -> bool {
+        match self.0 {}
+    }
+}
+
+impl Eq for ExitStatus {}
+
+impl fmt::Debug for ExitStatus {
+    fn fmt(&self, _f: &mut fmt::Formatter<'_>) -> fmt::Result {
+        match self.0 {}
+    }
+}
+
+impl fmt::Display for ExitStatus {
+    fn fmt(&self, _f: &mut fmt::Formatter<'_>) -> fmt::Result {
+        match self.0 {}
+    }
+}
diff --git a/library/std/src/sys/unix/thread.rs b/library/std/src/sys/unix/thread.rs
index cda17eb4bd2..29cfb3a4080 100644
--- a/library/std/src/sys/unix/thread.rs
+++ b/library/std/src/sys/unix/thread.rs
@@ -6,12 +6,14 @@ use crate::ptr;
 use crate::sys::{os, stack_overflow};
 use crate::time::Duration;
 
-#[cfg(not(any(target_os = "l4re", target_os = "vxworks")))]
+#[cfg(not(any(target_os = "l4re", target_os = "vxworks", target_os = "none")))]
 pub const DEFAULT_MIN_STACK_SIZE: usize = 2 * 1024 * 1024;
 #[cfg(target_os = "l4re")]
 pub const DEFAULT_MIN_STACK_SIZE: usize = 1024 * 1024;
 #[cfg(target_os = "vxworks")]
 pub const DEFAULT_MIN_STACK_SIZE: usize = 256 * 1024;
+#[cfg(target_os = "none")]
+pub const DEFAULT_MIN_STACK_SIZE: usize = 5 * 1024;
 
 pub struct Thread {
     id: libc::pthread_t,
@@ -32,22 +34,49 @@ impl Thread {
 
         let stack_size = cmp::max(stack, min_stack_size(&attr));
 
-        match libc::pthread_attr_setstacksize(&mut attr, stack_size) {
-            0 => {}
-            n => {
-                assert_eq!(n, libc::EINVAL);
-                // EINVAL means |stack_size| is either too small or not a
-                // multiple of the system page size.  Because it's definitely
-                // >= PTHREAD_STACK_MIN, it must be an alignment issue.
-                // Round up to the nearest page and try again.
-                let page_size = os::page_size();
-                let stack_size =
-                    (stack_size + page_size - 1) & (-(page_size as isize - 1) as usize - 1);
-                assert_eq!(libc::pthread_attr_setstacksize(&mut attr, stack_size), 0);
-            }
-        };
+        let stack_size_res = libc::pthread_attr_setstacksize(&mut attr, stack_size);
 
-        let ret = libc::pthread_create(&mut native, &attr, thread_start, p as *mut _);
+        if cfg!(target_env = "newlib") {
+            assert_eq!(stack_size_res, 0);
+        } else {
+            match stack_size_res {
+                0 => {}
+                n => {
+                    #[cfg(not(target_env = "newlib"))]
+                    use os::page_size;
+
+                    #[cfg(target_env = "newlib")]
+                    fn page_size() -> usize {unreachable!()}
+
+                    assert_eq!(n, libc::EINVAL);
+                    // EINVAL means |stack_size| is either too small or not a
+                    // multiple of the system page size.  Because it's definitely
+                    // >= PTHREAD_STACK_MIN, it must be an alignment issue.
+                    // Round up to the nearest page and try again.
+                    let page_size = page_size();
+                    let stack_size =
+                        (stack_size + page_size - 1) & (-(page_size as isize - 1) as usize - 1);
+                    assert_eq!(libc::pthread_attr_setstacksize(&mut attr, stack_size), 0);
+                }
+            };
+        }
+
+        // This hack is necessary because currently libc does not expose the
+        // pthread_create symbol under newlib
+        // TODO: File a pull request against libc
+        #[cfg(target_env = "newlib")]
+        extern "C" { 
+            fn pthread_create(
+                native: *mut libc::pthread_t, 
+                attr: *const libc::pthread_attr_t, 
+                f: extern "C" fn(_: *mut libc::c_void) -> *mut libc::c_void, 
+                value: *mut libc::c_void
+            ) -> libc::c_int;
+        }
+        #[cfg(not(target_env = "newlib"))]
+        use libc::pthread_create;
+        
+        let ret = pthread_create(&mut native, &attr, thread_start, p as *mut _);
         // Note: if the thread creation fails and this assert fails, then p will
         // be leaked. However, an alternative design could cause double-free
         // which is clearly worse.
@@ -147,6 +176,7 @@ impl Thread {
         // FIXME: determine whether Fuchsia has a way to set a thread name.
     }
 
+    #[cfg(not(target_env = "newlib"))]
     pub fn sleep(dur: Duration) {
         let mut secs = dur.as_secs();
         let mut nsecs = dur.subsec_nanos() as _;
@@ -172,6 +202,19 @@ impl Thread {
         }
     }
 
+    #[cfg(target_env = "newlib")]
+    pub fn sleep(dur: Duration) {
+        let mut micros = dur.as_micros();
+        unsafe {
+            while micros > 0 {
+                let st = if micros > u32::MAX as u128 {u32::MAX} else {micros as u32};
+                libc::usleep(st);
+
+                micros -= st as u128;
+            }
+        }
+    }
+
     pub fn join(self) {
         unsafe {
             let ret = libc::pthread_join(self.id, ptr::null_mut());
@@ -461,7 +504,7 @@ fn min_stack_size(attr: *const libc::pthread_attr_t) -> usize {
 
 // No point in looking up __pthread_get_minstack() on non-glibc
 // platforms.
-#[cfg(all(not(target_os = "linux"), not(target_os = "netbsd")))]
+#[cfg(all(not(target_os = "linux"), not(target_os = "netbsd"), not(target_os = "none")))]
 fn min_stack_size(_: *const libc::pthread_attr_t) -> usize {
     libc::PTHREAD_STACK_MIN
 }
@@ -470,3 +513,8 @@ fn min_stack_size(_: *const libc::pthread_attr_t) -> usize {
 fn min_stack_size(_: *const libc::pthread_attr_t) -> usize {
     2048 // just a guess
 }
+
+#[cfg(target_os = "none")]
+fn min_stack_size(_: *const libc::pthread_attr_t) -> usize {
+    512 // just a guess
+}
diff --git a/library/std/src/sys/unix/time.rs b/library/std/src/sys/unix/time.rs
index fac4b05ad0b..2d13f537c36 100644
--- a/library/std/src/sys/unix/time.rs
+++ b/library/std/src/sys/unix/time.rs
@@ -361,9 +361,9 @@ mod inner {
         }
     }
 
-    #[cfg(not(target_os = "dragonfly"))]
+    #[cfg(not(any(target_os = "dragonfly", target_env = "newlib")))]
     pub type clock_t = libc::c_int;
-    #[cfg(target_os = "dragonfly")]
+    #[cfg(any(target_os = "dragonfly", target_env = "newlib"))]
     pub type clock_t = libc::c_ulong;
 
     fn now(clock: clock_t) -> Timespec {
diff --git a/library/std/src/sys_common/alloc.rs b/library/std/src/sys_common/alloc.rs
index 6c1bc0d839a..578005e068d 100644
--- a/library/std/src/sys_common/alloc.rs
+++ b/library/std/src/sys_common/alloc.rs
@@ -16,7 +16,8 @@ use crate::ptr;
     target_arch = "asmjs",
     target_arch = "wasm32",
     target_arch = "hexagon",
-    target_arch = "riscv32"
+    target_arch = "riscv32",
+    target_arch = "xtensa"
 )))]
 pub const MIN_ALIGN: usize = 8;
 #[cfg(all(any(
-- 
2.17.1

